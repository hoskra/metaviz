<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="canvas">
  <meta name="author" content="hoskra">
  <script src="libs/p5.min.js" type="text/javascript" defer></script>
  <script src="libs/d3-delaunay@6.js" type="text/javascript" defer></script>
  <title>Delaunay</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>

<body>
</body>
<script>
  let p = []
  let dir = []
  const simplifiedPolygons = [];

  let W = 600
  let n = 7
  let f = 0

  let offset = 100
  let TOGGLE_CIRCLES = false
  let TOGGLE_VORONOI = true
  let TOGGLE_DELAUNAY = true

  function generatePoints() {
    function ran(set) {
      return set[Math.floor(Math.random() * set.length)]
    }

    for (let i = 0; i < n; i++) {
      p.push([offset + Math.random() * (W - offset), offset + Math.random() * (W - offset)])
      let randomDirection = ran([ [0, 1],[0, -1],[1, 0],[-1, 0]])
      dir.push([randomDirection[0], randomDirection[1]])
    }

    const delaunay = d3.Delaunay.from(p);
    const {points,halfedges,triangles} = delaunay;
    const voronoi = delaunay.voronoi([offset, offset, W-offset, W-offset])

    for (let cell of voronoi.cellPolygons()) {
      let polygon = [];
      for (let vertex of cell) { polygon.push([vertex[0], vertex[1]]); }
      simplifiedPolygons.push(polygon);
    }
  }

  generatePoints()

  function setup() {
    createCanvas(W, W)

    // xSensitivitySlider = createSlider(2, 20, n, 1);
  }

  function draw() {
    f += 0.01

    // let val = xSensitivitySlider.value();
    // if(val != n) {
      // n = xSensitivitySlider.value()
      // generatePoints()
    // }

    fill(255)

    // move points
    for (let i = 0; i < n; i++) {
      p[i][0] += parseFloat(dir[i][0]) * (2 * noise(i + f))
      p[i][1] += parseFloat(dir[i][1]) * (2 * noise(i + f))

      if (p[i][0] > W-offset) { dir[i][0] = -1 }
      if (p[i][0] < offset) { dir[i][0] = 1 }
      if (p[i][1] > W-offset) { dir[i][1] = -1 }
      if (p[i][1] < offset) { dir[i][1] = 1 }
    }

    const delaunay = d3.Delaunay.from(p);
    const { points,halfedges,triangles} = delaunay;
    const voronoi = delaunay.voronoi([0, 0, W, W])

    background(255)
    strokeWeight(1)

    const simplifiedPolygons = [];

    for (let cell of voronoi.cellPolygons()) {
      let polygon = [];
      for (let vertex of cell)
        polygon.push([vertex[0], vertex[1]]);
      simplifiedPolygons.push(polygon);
    }

    stroke(0)

    if(TOGGLE_DELAUNAY)
    for (let i = 0; i < points.length; i++) {
      const t0 = triangles[i * 3 + 0];
      const t1 = triangles[i * 3 + 1];
      const t2 = triangles[i * 3 + 2];
      x = [points[t0 * 2], points[t0 * 2 + 1]];
      y = [points[t1 * 2], points[t1 * 2 + 1]];
      z = [points[t2 * 2], points[t2 * 2 + 1]];
      line(x[0],x[1],y[0],y[1])
      line(y[0],y[1],z[0],z[1])
      line(z[0],z[1],x[0],x[1])
      // m = (Math.max(x[1], y[1]), z[1])
      // m = map(m, 0, 255, 0, 255)
      fill(0,50)
      triangle(x[0], x[1], y[0], y[1], z[0], z[1])
    }

    stroke(0)

    if(TOGGLE_VORONOI)
    for (let i = 0; i < simplifiedPolygons.length; i++) {
      let len = simplifiedPolygons[i].length
      for (let j = 0; j < simplifiedPolygons[i].length - 1; j++) {
        line(simplifiedPolygons[i][j][0], simplifiedPolygons[i][j][1],
          simplifiedPolygons[i][(j + 1) % len][0], simplifiedPolygons[i][(j + 1) % len][1])
      }
    }

    fill(0)

    if(TOGGLE_CIRCLES)
      for (let i = 0; i < p.length; i++) {
        circle(p[i][0], p[i][1], 2)
      }

  }
</script>

</html>