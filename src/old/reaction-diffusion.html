<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="canvas">
  <meta name="author" content="hoskra">
  <script src="../libs/p5.min.js" type="text/javascript" defer></script>
  <script src="../libs/d3-delaunay@6.js" type="text/javascript" defer></script>
  <title>Reaction Diffusion</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>

<body>
</body>
<script>
// https://www.karlsims.com/rd.html
// https://groups.csail.mit.edu/mac/projects/amorphous/GrayScott/
// https://www.youtube.com/watch?v=BV9ny785UNc
// https://www.youtube.com/watch?v=LMzYrsfTiEw
// https://biologicalmodeling.org/prologue/reaction-diffusion#turings-patterns-and-kl√ºvers-hallucinations

let t = 0
let W = 600

let grid = [];
let next = [];

function setup() {
  createCanvas(W, W)
  pixelDensity(1);
  for(let i = 0; i < W; i++){
    grid[i] = [];
    for(let j = 0; j < W; j++){
      // grid[i][j] = { a: 0, b: noise(i,i) };
      // grid[i][j] = { a: random(0,1), b: random(0,1) };
      grid[i][j] = { a: 1, b: 0 };
      // grid[i][j] = { a: 0, b: noise(i, i)/4  + noise(j, j)/4 + noise(i, j)/4 + noise(j, i)/4 };
    }
  }

  // circle
  let size = 10;
  let r = 100;
  for(let i = 0 ; i < W; i++){
    for(let j = 0 ; j < W; j++){
  let a = W/2-50;
  let b = W/2-50;
      if((pow(i-a,2))+pow(j-b,2) > pow(r, 2) &&
          (pow(i-a,2))+pow(j-b,2) < pow(r+50, 2) )
        grid[i][j].b = 1;

  a = W/2 + 50;
  b = W/2 + 50;
      if((pow(i-a,2))+pow(j-b,2) > pow(r, 2) &&
          (pow(i-a,2))+pow(j-b,2) < pow(r+50, 2) )
        grid[i][j].b = 1;

  a = W/2 - 50;
  b = W/2 + 50;
      if((pow(i-a,2))+pow(j-b,2) > pow(r, 2) &&
          (pow(i-a,2))+pow(j-b,2) < pow(r+50, 2) )
        grid[i][j].b = 1;
  a = W/2 + 50;
  b = W/2 - 50;
      if((pow(i-a,2))+pow(j-b,2) > pow(r, 2) &&
          (pow(i-a,2))+pow(j-b,2) < pow(r+50, 2) )
        grid[i][j].b = 1;
    }
  }


  next = grid;
}

// https://pmneila.github.io/jsexp/grayscott/

let dA = 1.0;
let dB = 0.5;
let f = 0.018;  // feed rate
let k = 0.051;  // kill rate


// let dA = 1.3;
// let dB = 0.2;
// let f = 0.08;  // feed rate
// let k = 0.06;  // kill rate

let laplaceKernel = [
  [0.05, 0.2, 0.05],
  [0.2, -1, 0.2],
  [0.05, 0.2, 0.05]
];

function draw() {
  t+=0.01;
  background(0)


  // for(let x = 0; x < W; x++){
  //   for(let y = 0; y < W; y++){
  for(let x = 1; x < W-1; x++){
    for(let y = 1; y < W-1; y++){
      let a = grid[x][y].a;
      let b = grid[x][y].b;
      let aNext = a + dA * laplaceA(x, y) - a * b * b + f * (1 - a);
      let bNext = b + dB * laplaceB(x, y) + a * b * b - (k + f) * b;
      next[x][y].a = constrain(aNext, 0, 1);
      next[x][y].b = constrain(bNext, 0, 1);
    }
  }

  loadPixels();

  for(let x = 1; x < W-1; x++){
    for(let y = 1; y < W-1; y++){
      let pix = (x + y * W) * 4;
      let a = next[x][y].a;
      let b = next[x][y].b;
      let c = floor((a - b) * 255);
      c = constrain(c, 0, 255);
      pixels[pix + 0] = c;
      pixels[pix + 1] = c;
      pixels[pix + 2] = c;
      pixels[pix + 3] = 255;
    }
  }

  updatePixels();
  swap();

}

function laplaceA(x, y) {
  if(x == 0) x = 1;
  if(x == W-1) x = W -2;
  if(y == 0) y = 1;
  if(y == W-1) y = W - 2;
  var sumA = 0;
  sumA += grid[x][y].a * laplaceKernel[1][1];
  sumA += grid[x - 1][y].a * laplaceKernel[0][1];
  sumA += grid[x + 1][y].a * laplaceKernel[2][1];
  sumA += grid[x][y - 1].a * laplaceKernel[1][0];
  sumA += grid[x][y + 1].a * laplaceKernel[1][2];
  sumA += grid[x - 1][y - 1].a * laplaceKernel[0][0];
  sumA += grid[x + 1][y - 1].a * laplaceKernel[0][2];
  sumA += grid[x + 1][y + 1].a * laplaceKernel[2][2];
  sumA += grid[x - 1][y + 1].a * laplaceKernel[2][0];
  return sumA;
}

function laplaceB(x, y) {
  if(x == 0) x = 1;
  if(x == W-1) x = W -2;
  if(y == 0) y = 1;
  if(y == W-1) y = W - 2;
  var sumB = 0;
  sumB += grid[x][y].b * laplaceKernel[1][1];
  sumB += grid[x - 1][y].b * laplaceKernel[0][1];
  sumB += grid[x + 1][y].b * laplaceKernel[2][1];
  sumB += grid[x][y - 1].b * laplaceKernel[1][0];
  sumB += grid[x][y + 1].b * laplaceKernel[1][2];
  sumB += grid[x - 1][y - 1].b * laplaceKernel[0][0];
  sumB += grid[x + 1][y - 1].b * laplaceKernel[0][2];
  sumB += grid[x + 1][y + 1].b * laplaceKernel[2][2];
  sumB += grid[x - 1][y + 1].b * laplaceKernel[2][0];
  return sumB;
}


// function laplaceA(x, y) {
//   let sum = 0;
//   for(let i = 0; i < 3; i++){
//     for(let j = 0; j < 3; j++){
//       sum += laplaceKernel[i][j] * grid[x + i - 1][y + j - 1].a;
//     }
//   }
//   return sum;
// }
// function laplaceB(x, y) {
//   let sum = 0;
//   for(let i = 0; i < 3; i++){
//     for(let j = 0; j < 3; j++){
//       sum += laplaceKernel[i][j] * grid[x + i - 1][y + j - 1].b;
//     }
//   }
//   return sum;
// }

function swap() {
  let tmp = grid;
  grid = next;
  next = tmp;
}

</script>
</html>